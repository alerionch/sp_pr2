;Задача: определить сумму элементов массива, превышающих заданную величину В, и количество элементов, меньших В.

section .data ;тут определяем переменные, которые будут в программе
    array db 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 ;массив со значениями
    array_len equ $-array ;длина массива (вычисляется путем вычитания адреса начала массива array из адреса конца массива )
    outp db "Сумма элементов, превышающих 30: %d; количество элементов, меньших 30: %d", 10, 0 ;строка для вывода. в %d будут подставляться посчитанные значения

section .text ;тут содержится сам текст программы
    global main ;объявляем точку входа в программу
    extern printf ; объявляем функцию printf для вывода результата

main:
    ;mov используется для копирования значения из одного регистра/ячейки памяти в другой регистр/ячейку памяти
    ;movzx также используется для копирования значения из одной ячейки памяти в другую ячейку памяти, но с расширением до большего размера данных. Расширение осуществляется путем добавления нулей слева до необходимого размера.
    
    mov rbp, rsp ; сохраняем текущее значение указателя стека rsp в регистре rbp перед тем, как стек будет изменен во время работы функции. После завершения функции указатель на стек будет восстановлен из rbp 
    ; Инициализация переменных
    mov rbx, 0 ; rbx - регистр, где хранится сумма элементов, превышающих B
    mov sil, 30 ; тут определяем B

    mov rdi, array ; в регистр rdi загружаем адрес начала массива array
    mov rcx, array_len ; в rcx загружается длина массива
    mov rdx, 0 ; в регистре rdx - счетчик меньших элементов

    loop_start: ;начало цикла
        movzx rax, byte [rdi] ; байт, находящийся по адресу, сохраненному в регистре rdi, загружается в регистр rax с помощью команды movzx
        cmp byte [rdi], sil ; сравниваем байт с B. 
        ;Команда cmp устанавливает флаги процессора в зависимости от результата сравнения, а именно, 
        ;если значение в байте меньше значения в sil, то флаг CF (Carry Flag) будет сброшен, а флаг ZF (Zero Flag) будет установлен, 
        ;иначе - флаг CF будет установлен, а флаг ZF будет сброшен.
        jle min; переходим в loop_end, если байт меньше или равен B (jle осуществляет переход, если флаг CF установлен)
        add rbx, rax ; добавляем байт к сумме если предыдущее условие не выполнилось (то есть значение больше В)

    min:
        cmp byte [rdi], sil ; сравниваем байт с B (также как и в предыдущем cmp)
        jge loop_end ; если значение в массиве >= В (jge осуществляет переход, если флаг CF сброшен), то переходим в loop_end
        inc rdx ; иначе добавляем 1 к значению rdx
        loop_end:
        inc rdi ;переходим на следующий байт в массиве array
        loop loop_start ; продолжаем цикл до конца массива


    ; Вывод результата
    and rsp, -16 ; Эта команда выравнивает значение указателя стека rsp до кратного 16, используя операцию побитового И (and) с отрицательным числом -16.
    ;При вызове  printf, требуется выровненный стек для правильной работы. В x86-64 системах требуется, чтобы стек был выровнен по кратному 16 значению.
        
    mov edi, outp ;загружаем адрес строки для вывода регистр edi
    mov rsi, rbx ;загружает значение суммы элементов в регистр rsi. Это значение будет выведено вместо первого %d 
    mov rdx, rdx ;загружает значение количества элементов в регистр rdx. Это значение будет выведено вместо второго %d
    xor eax, eax ; очищаем значение регистра eax, который используется для возвращаемого значения функции printf
    call printf ; вызывает функцию printf и выводим строку из outp с подставленными значениями
   
   
    ; Возврат из функции
    pop rbp ; восстанавливает значение указателя на стек, которое было сохранено в начале функции main для обеспечения корректной отладки
    mov rax, 0 ;загружает значение 0 в регистр rax, который используется для возвращаемого значения функции main
    ret  ;завершение работы программы. возвращает управление из функции main и передает значение в регистре rax в качестве возвращаемого значения. После этого управление передается операционной системе.
